import{d7 as We,d5 as Le,d6 as _e,dc as De,d9 as r,dd as Re,n as Qe,o as Oe,m as ne,r as re,dh as ie,bC as Ve,df as S,dg as A,db as E,dj as se,d3 as k,di as Xe,d4 as d}from"./index-CFG-wFBU.js";import{F as Ye}from"./CheckCircleIcon-DFJX5YLB.js";import{r as Ze,a as Je,l as Ke}from"./Layouts-Bmf8DxNP-BQV64GAA.js";import{s as oe}from"./ModalHeader-BTru6YQw-DYdjiBJP.js";import{r as ze}from"./ScreenHeader-Biz1wq02-B9MRprJJ.js";import{t as de}from"./FundWalletMethodHeader-CS84Ots9-D5rZZnNQ.js";import{t as Ge}from"./index-CJMgUOnw-GErmhyO9.js";import{c as et,t as tt}from"./useGetTokenPrice-CDPxMEO--B9h_z7D3.js";import{t as ce}from"./transfer-CMPmjPsM-Cjofo3yZ.js";import{t as at}from"./formatErc20TokenAmount-BuPk9xcy-CkAr4Oc0.js";import{n as nt,o as le,c as R,l as rt}from"./ethers-Bl5aM5Gz-CPjYqk2m.js";import{t as ue}from"./analytics-mkkvFRju-DOXuftJB.js";import{o as Q,u as me,d as fe,f as it}from"./reservoir-kvLjIrEo-ClDWaQL4.js";import{Q as st,Z as ot}from"./BridgeNetworkSelectionView-BXBCujiq-CgQJSW4H.js";import{n as dt}from"./getErc20Balance-CaKjNAs9-CRO7QHYS.js";import{I as ct}from"./TransferOrBridgeLoadingScreen-BY7Eot6x-BEYGPcEW.js";import{p as lt}from"./parseEther-DZ6PXuTV.js";import{c as ut}from"./custom-BEAm5Uyv.js";import"./useGetSolPrice-Cfm8o9C5-DtNHZcIm.js";import"./Button-BCV6mjvS-Diy1onH6.js";import"./Value-B4M62ove-BdVWEpHr.js";import"./LoadingSkeleton-CHdaq3pb-Dwv1_0Ax.js";import"./ErrorMessage-Cx8GKGhL-CTqv9rbm.js";import"./Subtitle-DkvfP2Ev-F2Rg9Sll.js";import"./Title-D0pfZff--DBaxWHKt.js";import"./WalletIcon-WEIa7Dk3.js";import"./getChainName-DjpPdUSc-c2urPd0g.js";import"./Chip-Bsgj4Yc--BnKnlMn6.js";import"./shared-CtYf3O54-uR8OvcTT.js";import"./ChevronDownIcon-BXoVhCTL.js";import"./styles-DY17fuAX-CB-11WQK.js";import"./formatters-Bijc2BBu.js";import"./InjectedWalletIcon-DLcYOGDj-C0KoKWcJ.js";import"./Address-BUmpXgsy-CF0mM5Dd.js";import"./check-5xMODKSu.js";import"./createLucideIcon-Bi9Ux4FY.js";import"./copy-CCL2rB9P.js";import"./GlobeAltIcon-B_UIftrx.js";import"./parseUnits-BUKE8lVI.js";const Kt={component:()=>{let{rpcConfig:F,appId:y,closePrivyModal:he,createAnalyticsEvent:O}=We(),{navigate:pe,setModalData:q,data:o}=Le(),V=_e(),{wallets:ge}=De(),[ve,ye]=r.useState(!1),[C,Ce]=r.useState(0n),[X,Y]=r.useState(!1),[H,g]=r.useState(null),[Ie,M]=r.useState(null),[I,Te]=r.useState([]),[Z,be]=r.useState(0),[J,x]=r.useState(!1),[W,j]=r.useState(!1),[K,L]=r.useState(!1),[_,z]=r.useState(!1),[we,Se]=r.useState(),[Ee,G]=r.useState();if(!o?.funding||o.funding.chainType!=="ethereum")throw Error("Invalid funding data");let{erc20ContractInfo:s,chain:t,connectedWallet:ee}=o.funding,h=o.funding.address,m=o.funding.erc20Address,[T,xe]=r.useState(o.funding.amount);r.useEffect((()=>{m&&!s&&g(Error("Unable to fetch token details"))}),[]);let c=!!m&&!!s,f=c?BigInt(parseFloat(T)*10**s.decimals):lt(T),a=(ee?.type==="ethereum"?ee:void 0)??ge[0],$e=Re(a?.walletClientType||"unknown"),te=$e?.name||"wallet",[v,Ne]=r.useState(null);r.useEffect((()=>{(async()=>{if(!a)return;let n=await a.getEthereumProvider();Ne(Qe({account:a.address,transport:ut(n)}).extend(Oe))})().catch(console.error)}),[a]);let[Ae,Fe]=r.useState(0n);r.useEffect((()=>{ne({chain:t,transport:re(ie(t,F,y))}).getBalance({address:h}).then(Fe).catch(console.error)}),[]);let[je,Be]=r.useState(0n);r.useEffect((()=>{c&&dt({chain:t,address:h,appId:y,rpcConfig:F,erc20Address:m}).then((n=>Be(n.balance))).catch(console.error)}),[]);let{tokenPrice:b}=et(t.id),[i,B]=r.useState({to:h,chain:t,value:f,data:void 0});r.useEffect((()=>{(async()=>{let n,l;if(!v||!a||J||K)return;x(!0);let w=ne({chain:i.chain,transport:re(ie(i.chain,F,y))});if(c&&!i.data)return await w.simulateContract({address:m,chain:i.chain,abi:ce,functionName:"transfer",args:[h,f],account:a.address}).catch((u=>{console.warn("Simulated token transfer failed with error, fetching bridge options.",u)}))?(x(!1),void B({to:m,chain:i.chain,data:Ve({abi:ce,functionName:"transfer",args:[h,f]}),value:"0x0"})):(x(!1),void Y(!0));try{n=await w.prepareTransactionRequest({account:a.address,to:i.to,chain:i.chain,data:i.data,value:BigInt(i.value??0)})}catch(u){if(console.error(u),I.length>1)M(u.shortMessage??"Something went wrong");else if(W&&I.length===0)return void g(new S(`Wallet ${A(a.address)} does not have enough funds.`,void 0,E.INSUFFICIENT_BALANCE))}if(!n)return x(!1),void Y(!0);x(!1),L(!0),ye(!0),Ce(n.gas);try{await v.switchChain({id:i.chain.id})}catch{await v.addChain({chain:i.chain}),await v.switchChain({id:i.chain.id})}try{l=await v.sendTransaction(n)}catch(u){if(console.error(u),u.name==="TransactionExecutionError")if(I.length<1){let P=u.shortMessage;(u.shortMessage.includes("rejected the request")||u.details.includes("rejected the request"))&&(P="User rejected the request."),g(new S(P,void 0,E.TRANSACTION_FAILURE))}else M(u.shortMessage??"Something went wrong")}if(l)return await v.waitForTransactionReceipt({hash:l}),L(!1),W?(Se(l),void G("pending")):(z(!0),q(se(o,"completed",l,a?.walletClientType,c,s,t)),void O({eventName:ue,payload:{provider:"external",status:"success",txHash:l,address:a.address,chainId:i.chain.id,chainType:"ethereum",value:i.value?k(BigInt(i.value),s?.decimals??18):void 0,token:s?.symbol??m??"ETH",destinationAddress:h,destinationChainId:t.id,destinationChainType:"ethereum",destinationValue:f?k(f,s?.decimals??18):void 0,destinationToken:s?.symbol??m??t.nativeCurrency.name}}));L(!1)})().catch(console.error)}),[v,i]),r.useEffect((()=>{(async()=>{if(!X||!v||!a)return;let n=tt(V.chains).filter((e=>e.id!==t.id&&!!e.testnet==!!t.testnet));c&&n.unshift(t);let l=await st({chains:n,address:a.address,appId:y,rpcConfig:F,includeUsdc:o.funding?.isUSDC}),w=c?l.filter((e=>e.balance>0n)):l.filter((e=>e.balance>f)),u=c&&l.every((e=>e.balance===0n));if(w.length<1)return void g(new S(u?`Wallet ${A(a.address)} doesn't have enough funds to cover gas fees. Top up your wallet and try again.`:`Wallet ${A(a.address)} does not have enough funds.`,void 0,E.INSUFFICIENT_BALANCE));w.sort(((e,N)=>Number(c?(N.erc20Balance??0n)-(e.erc20Balance??0n):N.balance-e.balance)));let P=w.flatMap((e=>{let N=[{...e,isErc20Quote:!1,isTestnet:!!t.testnet,input:Q({appId:y,amount:f.toString(),user:a.address,recipient:h,destinationChainId:t.id,destinationCurrency:m,originChainId:e.chain.id})}];return c&&m&&(e.erc20Balance??0n)>=f&&N.push({...e,isErc20Quote:!0,isTestnet:!!t.testnet,input:Q({appId:y,amount:f.toString(),user:a.address,recipient:h,destinationChainId:t.id,destinationCurrency:m,originChainId:e.chain.id,originCurrency:e.erc20Address})}),N})),ae=(await Promise.allSettled(P.map((async e=>({...e,quote:await me(e)}))))).filter((e=>e.status==="fulfilled")).map((e=>e.value));if(ae.length<1)return void g(new S(`Wallet ${A(a.address)} does not have enough funds.`,void 0,E.INSUFFICIENT_BALANCE));let D=ae.map((e=>({bridgeTx:fe(e.quote),balance:e.balance,chain:e.chain,erc20Balance:e.erc20Balance,isErc20Quote:e.isErc20Quote}))).filter((e=>!!e.bridgeTx));if(D.length>1)return void Te(D);let $=D[0];$?(j(!0),B({data:$.bridgeTx.data,to:$.bridgeTx.to,value:$.bridgeTx.value,chain:$.chain})):g(new S(`Wallet ${A(a.address)} does not have enough funds.`,void 0,E.INSUFFICIENT_BALANCE))})().catch(console.error)}),[X]),it({transactionHash:we,isTestnet:!!t.testnet,bridgingStatus:Ee,setBridgingStatus:G,onSuccess({transactionHash:n}){j(!1),z(!0),q(se(o,"completed",n,a?.walletClientType,c,s,t)),O({eventName:ue,payload:{provider:"external",status:"success",txHash:n,address:a?.address,chainId:i.chain.id,chainType:"ethereum",value:i.value?k(BigInt(i.value),s?.decimals??18):void 0,token:s?.symbol??m??"ETH",destinationAddress:h,destinationChainId:t.id,destinationChainType:"ethereum",destinationValue:f?k(f,s?.decimals??18):void 0,destinationToken:s?.symbol??m??t.nativeCurrency.name}})},onFailure({error:n}){j(!1),g(n)}}),r.useEffect((()=>{H&&(q({funding:o?.funding,solanaFundingData:o?.solanaFundingData,sendTransaction:o?.sendTransaction,errorModalData:{error:H,previousScreen:"TransferFromWalletScreen"}}),pe("ErrorScreen",!1))}),[H]);let Ue=!c&&b?nt(T??"0",b):void 0,U=c?C:rt([C,f]),Pe=U&&b?le(U,b):void 0,ke=U?R(U,o?.funding?.erc20Address?o?.funding?.erc20ContractInfo?.symbol||"ETH":o?.funding?.chain.nativeCurrency.symbol||"ETH"):void 0,qe=C&&b?le(C,b):void 0,He=C?R(C,t?.nativeCurrency?.symbol||"ETH"):void 0;if(r.useEffect((()=>{if(!_)return;let n=setTimeout(he,Xe);return()=>clearTimeout(n)}),[_]),_)return d.jsxs(d.Fragment,{children:[d.jsx(de,{}),d.jsx(Ze,{}),d.jsxs(Je,{children:[d.jsx(Ye,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),d.jsx(ze,{title:"Success!",description:`Youâ€™ve successfully added ${T} ${c?s.symbol:t.nativeCurrency.symbol} to your ${V.name} wallet. It may take a minute before the funds are available to use.`})]}),d.jsx(Ke,{}),d.jsx(oe,{})]});let Me=c?`${at({amount:je,decimals:s.decimals})}  ${s.symbol}`:R(Ae,t.nativeCurrency.symbol,3,!0),p=I[Z];return I.length>1&&p?d.jsx(ot,{displayName:te,configuredFundingChain:t,erc20ContractInfo:s,formattedBalance:Me,fundingAmount:T,fundingCurrency:c?s.symbol:t.nativeCurrency.symbol,fundingAmountInUsd:Ue,options:I,selectedOption:p,isPreparing:J,isSubmitting:K,addressToFund:h,fundingWalletAddress:a?.address||"",errorMessage:Ie,onSubmit:()=>{o.funding?.amount!==T?(async function(){if(a&&p)try{let n=await me({isTestnet:!!t.testnet,input:Q({appId:y,amount:f.toString(),user:a.address,recipient:h,destinationChainId:t.id,destinationCurrency:m,originChainId:p.chain.id})}),l=fe(n);if(!l)throw Error("Invalid transaction request");j(!0),B({data:l.data,to:l.to,value:l.value,chain:p.chain})}catch(n){console.error(n),g(new S("Unable to fetch quotes for bridging",n,E.INSUFFICIENT_BALANCE))}})().catch(console.error):B({to:p.bridgeTx.to,data:p.bridgeTx.data,value:p.bridgeTx.value,chain:p.chain})},onSelect:n=>{n!==Z&&(M(null),be(n))},onAmountChange:xe}):ve&&C&&a&&o?.funding?d.jsx(ct,{walletClientType:a?.walletClientType||"unknown",displayName:te,addressToFund:h,isBridging:W,isErc20Flow:c,totalPriceInUsd:Pe,totalPriceInNativeCurrency:ke,gasPriceInUsd:qe,gasPriceInNativeCurrency:He,chainId:t.id,chainName:t.name}):d.jsxs(d.Fragment,{children:[d.jsx(de,{}),d.jsx(Ge,{}),d.jsx("div",{style:{marginTop:"1rem"}}),d.jsx(oe,{})]})}};export{Kt as AwaitingExternalEthereumTransferScreen,Kt as default};
