import{dA as H,d5 as B,d7 as K,d8 as ne,df as i,db as _,dX as Y,dZ as de,d9 as f,dL as le,dw as ue,d4 as o,eg as he,ek as pe,el as ve,em as we,en as ye,eo as me,ep as ee,eq as fe}from"./index-CUKlbBka.js";import{n as G}from"./Button-BCV6mjvS-BVimNoDj.js";import{y as _e,s as Ee}from"./ModalHeader-BTru6YQw-BOw6POVk.js";import{r as X}from"./ScreenHeader-Biz1wq02-ClDsXrYg.js";import{t as Ae}from"./use-create-wallet-without-fallback-C0dI_RFZ-UjlmW5sr.js";import{e as ge,o as Ce,d as q}from"./styles-BxA7nKxI-CxAWMGuD.js";async function Q({url:h,popup:c,provider:p}){return c.location=h,new Promise(((s,n)=>{function d(){c?.close(),window.removeEventListener("message",l)}function l(a){a.data&&(a.data.type==="PRIVY_OAUTH_RESPONSE"&&a.data.stateCode&&a.data.authorizationCode&&(s(a.data),d()),a.origin==="https://cdn.apple-cloudkit.com"&&a.data.ckSession&&(s({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:a.data.ckSession}),d()),a.data.type==="PRIVY_OAUTH_ERROR"&&(n(a.data.error),d()))}window.addEventListener("message",l)}))}async function Re({api:h,provider:c,stateCode:p,codeVerifier:s,authorizationCode:n}){if(!n||!p)throw new i("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if(n==="undefined")throw new i("User denied confirmation during OAuth flow");try{return(await h.post(fe,{authorization_code:n,state_code:p,code_verifier:s,provider:c})).access_token}catch(d){let l=ee(d);throw l.privyErrorCode?new i(l.message||"Invalid code during OAuth flow.",void 0,l.privyErrorCode):l.message==="User denied confirmation during OAuth flow"?new i("Invalid code during oauth flow.",void 0,_.OAUTH_USER_DENIED):new i("Invalid code during OAuth flow.",void 0,_.UNKNOWN_AUTH_ERROR)}}async function J({api:h,provider:c}){let p=pe(),s=ve(),n=await we(p);try{return c==="icloud"?{url:(await h.post(ye,{client_type:"web"})).url}:{url:(await h.post(me,{redirect_to:window.location.href,code_challenge:n,state_code:s})).url,codeVerifier:p,stateCode:s,provider:c}}catch(d){throw ee(d)}}let Z={"google-drive":{name:"Google Drive",component:Ce},icloud:{name:"iCloud",component:ge}};const Ne={component:()=>{let{logout:h}=H(),{navigate:c,setModalData:p,data:s}=B(),{closePrivyModal:n,createAnalyticsEvent:d}=K(),{execute:l}=(()=>{let{client:t,walletProxy:w,refreshSessionAndUser:N}=K(),{data:A}=B(),{user:g}=H(),C=ne(),{create:T}=Ae();return{execute:async({provider:r,action:se,popup:P,shouldCreateEth:V,shouldCreateSol:L})=>{let R,y;if(!t)throw new i("Missing client");function F(e){if(!e&&t)throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:r}}),new i("Recovery OAuth failed")}switch(r){case"google-drive":{let e,u,{url:b,codeVerifier:O,stateCode:z}=await J({api:t.api,provider:r});F(b);try{let k=await Q({url:b,popup:P,provider:r});if(e=k.stateCode,u=k.authorizationCode,e!==z)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:z??"",returnedStateCode:e??""}}),new i("Unexpected auth flow. This may be a phishing attempt.",void 0,_.OAUTH_UNEXPECTED)}catch(k){throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:k.toString(),provider:r}}),new i("Recovery OAuth failed")}[R,y]=await Promise.all([t.getAccessToken(),Re({api:t.api,provider:r,codeVerifier:O,stateCode:e,authorizationCode:u})]);break}case"icloud":{let{url:e}=await J({api:t.api,provider:r});F(e);let{ckWebAuthToken:u}=await Q({url:e,popup:P,provider:r});y=u,R=await t.getAccessToken()}}if(!w)throw new i("Cannot connect to wallet proxy");if(!R)throw new i("Unable to authorize user");switch(se){case"recover":{let e=A?.recoverWallet?.entropyId,u=A?.recoverWallet?.entropyIdVerifier;if(!e||!u)throw new i("Recovery OAuth failed");t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:e,recoveryMethod:r}}),await w.recover({accessToken:R,entropyId:e,entropyIdVerifier:u,recoveryAccessToken:y}),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:e,recoveryMethod:r}});break}case"create-wallet":{let e;if(t.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),V&&L)e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g}),e=await T({chainType:"solana",walletIndex:0,latestUser:e.user});else if(L)e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"solana",walletIndex:0,latestUser:g});else{if(!V)throw Error("Invalid args to create wallet");e=await T({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g})}if(!e)throw C("createWallet","onError",_.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:e.account.address}}),C("createWallet","onSuccess",{wallet:e.account});break}case"set-recovery":{let e=Y(g);if(!e)throw C("setWalletRecovery","onError",_.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}});let{entropyId:u,entropyIdVerifier:b}=de(g);await w.setRecovery({accessToken:R,entropyId:u,entropyIdVerifier:b,recoveryMethod:r,recoveryAccessToken:y});let O=Y(await N());if(!O)throw C("createWallet","onError",_.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}}),C("setWalletRecovery","onSuccess",{method:r,wallet:O});break}default:throw new i("Unsupported recovery action")}}}})(),[a,U]=f.useState(!1),{provider:E,action:m,isInAccountCreateFlow:I,shouldCreateEth:te,shouldCreateSol:re}=s?.recoveryOAuthStatus,[v,M]=f.useState(void 0),[ae,oe]=f.useState(m==="create-wallet");if(E==="user-passcode")throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let W=Z[E].name,$=Z[E].component,D=s?.recoverWallet?.onCompleteNavigateTo,S=new le((async(t="create-wallet")=>(oe(!0),new Promise(((w,N)=>{setTimeout((async()=>{try{let A=window.open();await l({provider:E,action:t,popup:A,shouldCreateEth:te,shouldCreateSol:re}),U(!0),w()}catch{M({message:`${t==="recover"?"Recovery":"Back up"} with ${W} unsuccessful`,detail:m==="recover"?`Please verify that you are selecting the ${W} account associated with your backup.`:"",retryable:!0}),N()}}),0)})))));f.useEffect((()=>{m!=="recover"&&S.execute(I?"create-wallet":"set-recovery")}),[]),f.useEffect((()=>{if(!a)return;let t=setTimeout((()=>{I?(p({createWallet:{onSuccess:()=>{},onFailure:w=>{d({eventName:"embedded_wallet_creation_failure_logout",payload:{error:w,screen:"RecoveryOAuthScreen"}}),h()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),c("EmbeddedWalletCreatedScreen")):n({shouldCallAuthOnSuccess:!1})}),ue);return()=>clearTimeout(t)}),[a]);let j=f.useCallback((async()=>{await S.execute("recover"),D?c(D):U(!0)}),[]),x=E==="google-drive"?"Google Drive":"Apple iCloud",ie=a&&`Successfully ${m==="recover"?"recovered":"backed up"} with ${x}.`||v&&v.message||`${m==="recover"?"Recovering":"Backing up"} with ${x}...`,ce=v?v.detail:"";return o.jsxs(o.Fragment,{children:[o.jsx(_e,{}),ae?o.jsx(o.Fragment,{children:o.jsxs(q,{children:[o.jsx(X,{title:ie,icon:o.jsx($,{style:{width:"38px",height:"38px"}}),description:ce}),v&&v?.retryable?o.jsx(G,{onClick:()=>{he(),M(void 0),m==="create-wallet"?S.execute("create-wallet"):j()},disabled:!a&&!v?.retryable,children:"Try again"}):null]})}):o.jsxs(q,{children:[o.jsx(X,{title:"Confirm it's really you",icon:o.jsx($,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${x} where your account is backed up.`}),o.jsxs(G,{onClick:j,children:["Confirm with ",x]})]}),o.jsx(Ee,{})]})}};export{Ne as RecoveryOAuthScreen,Ne as default};
