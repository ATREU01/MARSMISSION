import{d6 as _,d7 as Se,d5 as Te,dc as we,d9 as a,dd as xe,n as Ce,o as ye,de as be,df as g,dg as B,db as v,m as Ee,r as Ne,dh as Fe,d3 as C,di as Ae,d4 as i}from"./index-3CuyeEXd.js";import{F as $e}from"./CheckCircleIcon-BVwJujcP.js";import{r as Ue,a as je,l as Be}from"./Layouts-Bmf8DxNP-CI3o64MK.js";import{s as V}from"./ModalHeader-BTru6YQw-Cho8yYGx.js";import{r as Pe}from"./ScreenHeader-Biz1wq02-DrCTkS1r.js";import{t as Q}from"./FundWalletMethodHeader-CS84Ots9-CY2hZanT.js";import{t as ke}from"./index-CJMgUOnw-DFxtpEnK.js";import{c as Le,t as qe}from"./useGetTokenPrice-CDPxMEO--MeHz7_8v.js";import{t as Y}from"./analytics-mkkvFRju-DOXuftJB.js";import{u as Z,o as z,s as G,r as J,d as K,f as Me}from"./reservoir-kvLjIrEo-CpTp0_2F.js";import{e as We}from"./getChainName-DjpPdUSc-c2urPd0g.js";import{t as Re,n as De}from"./transaction-CnfuREWo-nROljJQP.js";import{Q as He,Z as Oe}from"./BridgeNetworkSelectionView-BXBCujiq-DguwiuH6.js";import{I as _e}from"./TransferOrBridgeLoadingScreen-BY7Eot6x-CwT5Sncv.js";import{c as Ve}from"./custom-CCwP7LDZ.js";import"./useGetSolPrice-Cfm8o9C5-Cxl-ykrp.js";import"./getFormattedUsdFromLamports-B6EqSEho-C-HCdwKa.js";import"./getErc20Balance-CaKjNAs9-sRmr-p46.js";import"./Button-BCV6mjvS-BmN5ircB.js";import"./Value-B4M62ove-BgFNWV75.js";import"./LoadingSkeleton-CHdaq3pb-CFR7ZnUF.js";import"./ErrorMessage-Cx8GKGhL-nEhhg4Ww.js";import"./Subtitle-DkvfP2Ev-tKa4H3E0.js";import"./Title-D0pfZff--DZlzEYG9.js";import"./WalletIcon-BILrcMYS.js";import"./Chip-Bsgj4Yc--BrXBdFoa.js";import"./shared-CtYf3O54-DOgjQamr.js";import"./ChevronDownIcon-CBnXYxt_.js";import"./formatErc20TokenAmount-BuPk9xcy-CkAr4Oc0.js";import"./ethers-Bl5aM5Gz-DawqJY7N.js";import"./styles-DY17fuAX-mr9vAgHc.js";import"./formatters-EiDssw70.js";import"./InjectedWalletIcon-DLcYOGDj-FWZxtEp1.js";import"./Address-BUmpXgsy-DRHOfCK6.js";import"./check-DaEC9Ajt.js";import"./createLucideIcon-odzGZ_-w.js";import"./copy-W_wpEvwR.js";import"./GlobeAltIcon-DJkkbBS5.js";const $t={component:()=>{let X=_(),{rpcConfig:P,appId:I,closePrivyModal:ee,createAnalyticsEvent:k}=Se(),{navigate:te,setModalData:ae,data:d}=Te(),L=_(),{wallets:ne}=we(),[y,m]=a.useState(null),[ie,b]=a.useState(null),[p,re]=a.useState([]),[q,se]=a.useState(0),[M,E]=a.useState(!1),[W,S]=a.useState(!1),[N,F]=a.useState(!1),[A,R]=a.useState(!1),[oe,de]=a.useState(),[le,D]=a.useState();if(!d?.funding||d.funding.chainType!=="solana")throw Error("Invalid funding data");let{address:u,chain:T,connectedWallet:H}=d.funding,[w,ce]=a.useState(d.funding.amount),t=(H?.type==="ethereum"?H:void 0)??ne[0],ue=xe(t?.walletClientType||"unknown"),O=ue?.name||"wallet",[l,me]=a.useState(null);a.useEffect((()=>{(async()=>{if(!t)return;let e=await t.getEthereumProvider();me(Ce({account:t.address,transport:Ve(e)}).extend(ye))})().catch(console.error)}),[t]);let[pe,fe]=a.useState(0n),he=Re(pe);a.useEffect((()=>{let e=X.solanaRpcs[T];e?be({rpc:e.rpc,address:u}).then((s=>fe(BigInt(s)))).catch(console.error):console.warn("Unable to load solana rpc, skipping balance")}),[]);let[n,$]=a.useState(),{tokenPrice:ge}=Le("solana"),{fundingAmountInBaseUnit:x,fundingAmountInUsd:ve}=De({amount:w,fee:0n,tokenPrice:ge,isUsdc:d.funding.isUSDC});if(a.useEffect((()=>{(async()=>{if(!l||!t)return;let e=["solana:testnet","solana:devnet"].includes(T);e&&console.warn("Solana testnets are not supported for bridging");let s=qe(L.chains).filter((({testnet:r})=>!!r===e)),f=(await He({chains:s,address:t.address,appId:I,rpcConfig:P})).filter((r=>r.balance>0n));if(f.length<1)return void m(new g(`Wallet ${B(t.address)} does not have enough funds.`,void 0,v.INSUFFICIENT_BALANCE));f.sort(((r,j)=>Number(j.balance-r.balance)));let o=(await Promise.allSettled(f.map((async r=>({...r,quote:await Z({isTestnet:!1,input:z({appId:I,amount:x.toString(),user:t.address,recipient:u,destinationChainId:J,destinationCurrency:G,originChainId:r.chain.id})})}))))).filter((r=>r.status==="fulfilled")).map((r=>r.value));if(o.length<1)return void m(new g(`Unable to fetch quotes for bridging. Wallet ${B(t.address)} does not have enough funds.`,void 0,v.INSUFFICIENT_BALANCE));let U=o.map((({quote:r,balance:j,chain:Ie})=>({bridgeTx:K(r),balance:j,chain:Ie,isErc20Quote:!1}))).filter((({bridgeTx:r})=>!!r));if(U.length>1)return void re(U);let h=U.at(0);h?(S(!0),$({data:h.bridgeTx.data,to:h.bridgeTx.to,value:h.bridgeTx.value,chain:h.chain})):m(new g(`Unable to select bridge option from quotes. Wallet ${B(t.address)} does not have enough funds.`,void 0,v.INSUFFICIENT_BALANCE))})().catch(console.error)}),[l]),a.useEffect((()=>{(async()=>{let e,s;if(!l||!t||M||N||!n)return;E(!0);let f=Ee({chain:n.chain,transport:Ne(Fe(n.chain,P,I))});try{e=await f.prepareTransactionRequest({account:t.address,to:n.to,chain:n.chain,data:n.data,value:BigInt(n.value??0)})}catch(o){console.error(o),p.length>1&&b(o.shortMessage??"Something went wrong")}if(e){E(!1),F(!0);try{await l.switchChain({id:n.chain.id})}catch{await l.addChain({chain:n.chain}),await l.switchChain({id:n.chain.id})}try{s=await l.sendTransaction(e)}catch(o){console.error(o),o.name==="TransactionExecutionError"&&(p.length<1?m(new g(o.shortMessage,void 0,v.TRANSACTION_FAILURE)):b(o.shortMessage??"Something went wrong"))}if(s)return await l.waitForTransactionReceipt({hash:s}),W?(D("pending"),void de(s)):(F(!1),R(!0),void k({eventName:Y,payload:{provider:"external",status:"success",txHash:s,address:t.address,chainId:n.chain.id,chainType:"ethereum",value:n.value?C(BigInt(n.value),18):void 0,token:"ETH",destination:u,destinationClusterName:"mainnet-beta",destinationChainType:"solana",destinationValue:C(x,9),destinationToken:"SOL"}}));F(!1)}else E(!1)})().catch(console.error)}),[l,n]),Me({transactionHash:oe,isTestnet:!1,bridgingStatus:le,setBridgingStatus:D,onSuccess({transactionHash:e}){S(!1),R(!0),k({eventName:Y,payload:{provider:"external",status:"success",txHash:e,address:t?.address,chainId:n?.chain.id,chainType:"ethereum",value:n?.value?C(BigInt(n.value),18):void 0,token:"ETH",destination:u,destinationClusterName:"mainnet-beta",destinationChainType:"solana",destinationValue:C(x,9),destinationToken:"SOL"}})},onFailure({error:e}){S(!1),m(e)}}),a.useEffect((()=>{y&&(ae({funding:d?.funding,solanaFundingData:d?.solanaFundingData,sendTransaction:d?.sendTransaction,errorModalData:{error:y,previousScreen:"TransferFromWalletScreen"}}),te("ErrorScreen",!1))}),[y]),a.useEffect((()=>{if(!A)return;let e=setTimeout(ee,Ae);return()=>clearTimeout(e)}),[A]),A)return i.jsxs(i.Fragment,{children:[i.jsx(Q,{}),i.jsx(Ue,{}),i.jsxs(je,{children:[i.jsx($e,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),i.jsx(Pe,{title:"Success!",description:`Youâ€™ve successfully added ${w} SOL to your ${L.name} wallet. It may take a minute before the funds are available to use.`})]}),i.jsx(Be,{}),i.jsx(V,{})]});let c=p[q];return p.length>1&&c?i.jsx(Oe,{displayName:O,configuredFundingChain:T,formattedBalance:he,fundingAmount:w,fundingCurrency:"SOL",fundingAmountInUsd:ve,options:p,selectedOption:c,isPreparing:M,isSubmitting:N,addressToFund:u,fundingWalletAddress:t?.address||"",errorMessage:ie,onSubmit:()=>{d.funding?.amount!==w?(async function(){if(t&&c)try{let e=await Z({isTestnet:!1,input:z({appId:I,amount:x.toString(),user:t.address,recipient:u,destinationChainId:J,destinationCurrency:G,originChainId:c.chain.id})}),s=K(e);if(!s)throw Error("Invalid transaction request");S(!0),$({data:s.data,to:s.to,value:s.value,chain:c.chain})}catch(e){console.error(e),m(new g("Unable to fetch quotes for bridging",e,v.INSUFFICIENT_BALANCE))}})().catch(console.error):$({to:c.bridgeTx.to,data:c.bridgeTx.data,value:c.bridgeTx.value,chain:c.chain})},onSelect:e=>{e!==q&&(b(null),se(e))},onAmountChange:ce}):N&&t?i.jsx(_e,{walletClientType:t?.walletClientType||"unknown",displayName:O,addressToFund:u,isBridging:W,isErc20Flow:!1,chainId:"solana",chainName:We(T),totalPriceInUsd:void 0,totalPriceInNativeCurrency:void 0,gasPriceInUsd:void 0,gasPriceInNativeCurrency:void 0}):i.jsxs(i.Fragment,{children:[i.jsx(Q,{}),i.jsx(ke,{}),i.jsx("div",{style:{marginTop:"1rem"}}),i.jsx(V,{})]})}};export{$t as AwaitingEvmToSolBridgingScreen,$t as default};
